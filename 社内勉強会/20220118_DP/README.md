---
marp: true
---

# DP 動的計画法を解く

---
# 動的計画法とは
アルゴリズムの中で状態遷移に着目して解く手法
状態の変化を漸化式として実装して、演繹法的に結果を求めていきます。

今回はDP典型コンテストを順に解いていきます。

https://atcoder.jp/contests/dp/

---

# A - Frog 1
N 個の足場があります。 足場には 1,2,…,N と番号が振られています。 
各 i (1≤i≤N) について、足場 i の高さは h です。

最初、足場 1 にカエルがいます。
カエルは次の行動を何回か繰り返し、足場 N まで辿り着こうとしています。

足場 i にいるとき、足場 i+1 または i+2 へジャンプする。 
このとき、ジャンプ先の足場を j とすると、コスト ∣h_i − h_j ∣ を支払う。
カエルが足場 N に辿り着くまでに支払うコストの総和の最小値を求めてください。

---

# A - Frog 1

## ３番目の足場に飛ぶコストは、以下の小さい方
* １番目に辿り着くコスト + １から３に飛ぶコスト
* ２番目に辿り着くコスト + ２から３に飛ぶコスト

## ４番目の足場に飛ぶコストは、以下の小さい方
* ２番目に辿り着くコスト + ２から４に飛ぶコスト
* ３番目に辿り着くコスト + ３から４に飛ぶコスト
---

# A - Frog 1

一般化すると、

## N番目の足場に飛ぶコストは、以下の小さい方
* N-2番目に辿り着くコスト + N-2からNに飛ぶコスト
* N-1番目に辿り着くコスト + N-1からNに飛ぶコスト

最初2つのコストは分かっているので…

---

# A - Frog 1
まず足場と、そこにたどり着くコストのリストを作り、無限大で初期化します。
足場1に到達するためのコスト=dp[0]に0を設定します。
以下をN回繰り返します
* 現在の足場から1歩飛んだ先のコストを計算して編集
* 現在の足場から2歩飛んだ先のコストを計算して編集

それぞれ、飛んだ先／飛ぶ前の差を計算して、飛ぶ前のコストに加算
既に値が設定されている場合は、今の値と計算したコストの小さい方。
2歩飛んだら飛びすぎる場合を考慮して例外処理を追加

---

# B - Frog 2

N 個の足場があります。 足場には 1,2,…,N と番号が振られています。 
各 i (1≤i≤N) について、足場 i の高さは h_iです。

最初、足場 1 にカエルがいます。
カエルは次の行動を何回か繰り返し、足場 N まで辿り着こうとしています。

足場 i にいるとき、足場 i+1,i+2,…,i+K のどれかへジャンプする。 
このとき、ジャンプ先の足場を j とすると、コスト ∣h_i − h_j ∣ を支払う。
カエルが足場 N に辿り着くまでに支払うコストの総和の最小値を求めてください。

---

# B - Frog 2
カエルが飛ぶ先が１、２だけでなく、最大Kまで飛びます。
なので、
* 現在の足場から1歩飛んだ先のコストを計算して編集
* 現在の足場から2歩飛んだ先のコストを計算して編集
...
の部分もループで実装します。
ただし、飛んだ先が足場の数を飛びこさないように注意します。


---

# C - Vacation 

明日から太郎君の夏休みが始まります。 太郎君は夏休みの計画を立てることにしました。

夏休みは N 日からなります。 各 i (1≤i≤N) について、i 日目には太郎君は次の活動のうちひとつを選んで行います。

A: 海で泳ぐ。 幸福度 a_i を得る。
B: 山で虫取りをする。 幸福度 b_i を得る。
C: 家で宿題をする。 幸福度 c_i を得る。
太郎君は飽き性なので、2 日以上連続で同じ活動を行うことはできません。

太郎君が得る幸福度の総和の最大値を求めてください。

---

# C - Vacation 
dpのリストが直列なリスト形式ではなく、選んだ選択肢によって変わってくるので、
3列用意しましょう。
i+1日目にAを選んだ時の満足度は、i日目がBかCなので、
dp[A][i+1] = max(dp[B][i] + A[i],dp[C][i] + A[i])
と表現できます。

---

# まとめ
DPは漸化式、状態の遷移を式で表して、順に処理していく解き方
ある手続きを何回か繰り返して、結果を調べたいときに有効。

状態を保持するためのメモ変数を適切に用意するのが重要。
メモ[i]には、メモ[i-1]の状態値にi回目に処理した結果を入れる、
等のindexを間違えないように気を付ける。

