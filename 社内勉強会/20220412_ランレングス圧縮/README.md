---
marp: true
---

# ランレングス圧縮

---------------------------------------------
# はじめに
- 久し振りのテーマチャレンジです。
- ランレングス圧縮とはデータ圧縮アルゴリズムの一つで、可逆圧縮に分類される。
- ランレングス圧縮、RLE (Run Length Encoding) とも呼ばれる。

---------------------------------------------

# ランレングス圧縮とは
- 連長圧縮では、ある連続したデータを、そのデータ一つ分と連続した長さで表現することで圧縮している。
- 例えば、「A A A A A B B B B B B B B B A A A」は「A 5 B 9 A 3」と表せる。
- これは、Aが5回続き、そのあとにBが9回、そしてAが3回続いていることを表している
- （連続回数を、元のデータを表す符号の前に記録することもある。
- その場合、符号化した後は「5 A 9 B 3 A」と表される）。

---------------------------------------------

# ランレングス圧縮とは

- さらに、データがこの2種類（AとB）だけで、最初にAが来ることにしておけば、「5 9 3」だけで表せる。
- このルールに従ったときにBが最初に見つかった場合は、最初にAが0回連続していることにすれば良い。
- 例えば、「B B B A A A A A B B B B B A A A」は「0 3 5 5 3」で表せることになる。

---------------------------------------------------

# pythonでは
itertoolsのgroupbyを使うことでリストをグループごとに集計できるので、簡単に解ける。

from itertools import groupby

https://docs.python.org/ja/3/library/itertools.html#itertools.groupby

---------------------------------------------------
# Javaとかで実装するなら

```
	public static List[] groupby(String s){
		List keys=new ArrayList();	// キーリスト
		List lengths=new ArrayList();	// 要素長さリスト
		keys.add(s.charAt(0)); // 1文字目を追加
		lengths.add(1);			// 1文字目のカウント
		for(int i=1;i<s.length();i++){
			char c=s.charAt(i);		// N文字目を取得
			int j=keys.size()-1;	// グループ末尾を取得
			if(c==(char) keys.get(j)){	// グループ末尾と同じ文字ならカウントアップ
				lengths.set(j,((int) lengths.get(j)) +1);
			}else{
				keys.add(c);	// グループ末尾と違う文字なら
				lengths.add(1);	// 新規グループ1文字目として追加
			}
		}
		List[] result = {keys,lengths};
		return result;
	}
```
---------------------------------------------------

# ABC019 B - 高橋くんと文字列圧縮 
高橋くんはある文字列 s を持っています。
文字列を短く表現することに興味のある高橋くんは、以下の圧縮方法を試してみることにしました。

あなたには文字列 s が与えられるので、上記の方法で圧縮された文字列を求めるプログラムを、高橋くんの代わりに書いてください。

---------------------------------------------------

# ABC019 B - 高橋くんと文字列圧縮 
文字列 s を同じ文字が連続する文字列に分割します。（分割）
分割された各文字列を、文字と、その文字が連続する長さをつなげた新たな文字列に変換します。（変換）
最後に、変換した各文字列を前から順に結合します。（結合）
aabbbaad という文字列に上記の圧縮方法を適用すると

aabbbaad を aa bbb aa d に分割
aa bbb aa d を、それぞれ a2 b3 a2 d1 に変換
a2 b3 a2 d1 を a2b3a2d1 と結合
以上より、a2b3a2d1 を得ることができます。

---------------------------------------------------

# ABC122 B - ATCoder
英大文字からなる文字列 S が与えられます。S の部分文字列 (注記を参照) であるような最も長い ACGT 文字列 の長さを求めてください。

ここで、ACGT 文字列とは A, C, G, T 以外の文字を含まない文字列です。

---------------------------------------------------

# ABC122 B - ATCoder
Run-Length実装してグループ化した後、キー値がACGTか、を判定して、長さを足していく。

---------------------------------------------------

# AtCoder ABC 143 C - Slimes
N 匹のスライムが横一列に並んでいます。
これらの色に関する情報が、長さ N の英小文字から成る文字列 S で与えられます。
左から i 番目のスライムは、 S の i 文字目に対応する色を持っています。

同じ色を持ち隣接するスライムは融合し、色は変わらずに 1 匹のスライムとなります。
このとき、融合した後のスライムは、融合する前の各スライムが隣接していた他のスライムと隣接した状態になります。

最終的に存在するスライムは何匹となるでしょうか。

---------------------------------------------------

# AtCoder ABC 143 C - Slimes
だいたい同じ。
スライムをグループ化して圧縮して、残った種類を調べる。

---------------------------------------------------

# ABC116 C - Grand Garden
チャレンジ問題。
花壇に N 本の花が咲いており、それぞれ 1,2,......,N と番号が振られています。
最初、全ての花の高さは 0 です。 
数列 h={h 1 ,h 2 ,h 3 ,......} が入力として与えられます。
以下の「水やり」操作を繰り返すことで、すべての k(1≦k≦N) に対して花 k の高さを h kにしたいです。

整数 l,r を指定する。
l≦x≦r を満たすすべての x に対して、花 x の高さを 1 高くする。
条件を満たすための最小の「水やり」操作の回数を求めてください。

---------------------------------------------------

# ABC116 C - Grand Garden
達成したい高さ毎に水やりが必要かどうか、を考える。
高さ毎の2次元配列を作って、何か所に水やりが必要か、を考えていけばよい。